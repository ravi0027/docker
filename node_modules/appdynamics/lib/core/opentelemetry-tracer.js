'use strict';

const opentelemetry_api = require('@opentelemetry/api');
const { ROOT_CONTEXT } = require('@opentelemetry/api');
const { BatchSpanProcessor, ConsoleSpanExporter, BasicTracerProvider } = require('@opentelemetry/sdk-trace-base');
const { OTLPTraceExporter } = require("@opentelemetry/exporter-trace-otlp-proto");
const { AsyncHooksContextManager, AsyncLocalStorageContextManager } = require("@opentelemetry/context-async-hooks");
const { ParentBasedSampler, AlwaysOnSampler } = require("@opentelemetry/core");
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const url = require('url');

module.exports = TracerProvider;

function TracerProvider(logger) {
  this.host = 'localhost';
  this.port = '55681';
  this.ot_api = opentelemetry_api;
  this.ROOT_CONTEXT = ROOT_CONTEXT;
  this.logger = logger;
}

TracerProvider.prototype.register = function(config) {
  const provider = new BasicTracerProvider({
    sampler: new ParentBasedSampler({
      root: new AlwaysOnSampler()
    }),
    resource: new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: config.tierName,
      "service.name": config.tierName,
      "service.namespace": config.applicationName
    }),
  });

  // default collector configuration, can be overridden from agent config
  const collectorOptions = {
    attributes: {'service.name': config.tierName,
                 'service.namespace': config.applicationName}
  };

  // batch export config, empty by default
  const batchExporterConfig = {};

  if (config.openTelemetry) {
    if (config.openTelemetry.collector) {
      Object.assign(collectorOptions, config.openTelemetry.collector);
      this.url = collectorOptions.url;
      try {
        var urlObj = url.parse(this.url);
        this.host = urlObj.hostname;
        this.port = urlObj.port;
      } catch (e) {
        this.logger.error('Collector url must be in <host>:<port> format');
        return false;
      }
    }
    if(config.openTelemetry.exporter) {
      if(config.openTelemetry.exporter.maxExportBatchSize) {
        batchExporterConfig.maxExportBatchSize = config.openTelemetry.exporter.maxExportBatchSize;
      }
      if(config.openTelemetry.exporter.maxQueueSize) {
        batchExporterConfig.maxQueueSize = config.openTelemetry.exporter.maxQueueSize;
      }
      if(config.openTelemetry.exporter.exportTimeoutMillis) {
        batchExporterConfig.exportTimeoutMillis = config.openTelemetry.exporter.exportTimeoutMillis;
      }
      if(config.openTelemetry.exporter.maxExportBatchSize) {
        batchExporterConfig.maxExportBatchSize = config.openTelemetry.exporter.maxExportBatchSize;
      }
    }
  }

  const exporter = new OTLPTraceExporter(collectorOptions);
  provider.addSpanProcessor(new BatchSpanProcessor(exporter, batchExporterConfig));
  if (config.openTelemetry && config.openTelemetry.debug) {
    provider.addSpanProcessor(new BatchSpanProcessor(new ConsoleSpanExporter(), batchExporterConfig));
  }

  const majorVersion = parseInt(process.versions.node.split('.')[0]);
  const minorVersion = parseInt(process.versions.node.split('.')[1]);
  const contextManager = majorVersion > 14 || majorVersion == 14 && minorVersion >= 8 ?
    AsyncLocalStorageContextManager : AsyncHooksContextManager;
  provider.register({contextManager: new contextManager()});
  return true;
};

TracerProvider.prototype.getTracer = function(name) {
  return opentelemetry_api.trace.getTracer(name);
};
